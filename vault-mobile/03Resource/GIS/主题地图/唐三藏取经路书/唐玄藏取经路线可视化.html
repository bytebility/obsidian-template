<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å”ç„è—å–ç»è·¯çº¿å¯è§†åŒ–</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #8B4513, #D2691E);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }
        .container {
            display: flex;
            height: calc(100vh - 120px);
            gap: 20px;
            padding: 20px;
        }
        .map-container {
            flex: 1;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        .info-panel {
            width: 350px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            padding: 20px;
            overflow-y: auto;
        }
        .info-panel h3 {
            color: #8B4513;
            border-bottom: 2px solid #D2691E;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .route-info {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .route-info h4 {
            color: #8B4513;
            margin-top: 0;
        }
        .location-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .location-item {
            padding: 10px;
            border-left: 3px solid #D2691E;
            margin-bottom: 10px;
            background: #fafafa;
            border-radius: 0 5px 5px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .location-item:hover {
            background: #f0f0f0;
            border-left-color: #8B4513;
            transform: translateX(5px);
        }
        .location-item.active {
            background: #e8f4f8;
            border-left-color: #2196F3;
        }
        .location-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .location-coords {
            font-size: 0.9em;
            color: #666;
            font-family: monospace;
        }
        .controls {
            margin-bottom: 20px;
        }
        .btn {
            background: #8B4513;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background 0.3s ease;
        }
        .btn:hover {
            background: #D2691E;
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .animation-progress {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8B4513, #D2691E);
            width: 0%;
            transition: width 0.3s ease;
        }
        .legend {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 10px;
            border-radius: 2px;
        }
        .route-line { background: #FF6B6B; }
        .start-point { background: #4CAF50; }
        .end-point { background: #2196F3; }
        .way-point { background: #FF9800; }
        .animation-marker { background: #E91E63; }

        /* æµ®åŠ¨è¿›åº¦æ˜¾ç¤ºé¢æ¿ */
        .floating-progress-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(139, 69, 19, 0.95);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 300px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            display: none;
        }

        .progress-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #FFD700;
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .progress-stat {
            flex: 1;
            text-align: center;
            padding: 0 5px;
        }

        .progress-stat .label {
            font-size: 11px;
            opacity: 0.8;
            margin-bottom: 2px;
        }

        .progress-stat .value {
            font-weight: bold;
            font-size: 14px;
        }

        .progress-bar-large {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill-large {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .current-location {
            font-size: 12px;
            margin-top: 8px;
            opacity: 0.9;
            font-style: italic;
        }
    </style>
</head>
<body>
    <!-- æµ®åŠ¨è¿›åº¦æ˜¾ç¤ºé¢æ¿ -->
    <div class="floating-progress-panel" id="floatingProgressPanel">
        <div class="progress-title">ğŸš¶â€â™‚ï¸ å–ç»è¿›åº¦</div>
        <div class="progress-stats">
            <div class="progress-stat">
                <div class="label">å·²å®Œæˆ</div>
                <div class="value" id="completedDistance">0 km</div>
            </div>
            <div class="progress-stat">
                <div class="label">æ€»è·¯ç¨‹</div>
                <div class="value" id="totalDistanceDisplay">0 km</div>
            </div>
            <div class="progress-stat">
                <div class="label">å‰©ä½™</div>
                <div class="value" id="remainingDistance">0 km</div>
            </div>
        </div>
        <div class="progress-bar-large">
            <div class="progress-fill-large" id="progressFillLarge"></div>
        </div>
        <div class="progress-text" id="progressTextLarge">0%</div>
        <div class="current-location" id="currentLocationText">å‡†å¤‡å‡ºå‘...</div>
    </div>

    <div class="header">
        <h1>å”ç„è—å–ç»è·¯çº¿</h1>
        <p>ä»é•¿å®‰åˆ°å¤©ç«º - å†æ—¶17å¹´çš„è¥¿è¡Œå–ç»ä¹‹æ—…</p>
    </div>

    <div class="container">
        <div class="map-container">
            <div id="map"></div>
            <div class="animation-progress" id="animationProgress">
                <div><strong>åŠ¨ç”»è¿›åº¦</strong></div>
                <div id="currentLocation">
                    <div style="font-size: 12px;">
                        <div><strong>å½“å‰ä½ç½®:</strong> ç­‰å¾…å¼€å§‹...</div>
                        <div style="margin-top: 3px; color: #666;">
                            <strong>æ€»è·¯ç¨‹:</strong> <span id="totalDistance">è®¡ç®—ä¸­...</span>
                        </div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
        </div>

        <div class="info-panel">
            <h3>è·¯çº¿ä¿¡æ¯</h3>
            <div class="route-info">
                <h4>å–ç»è·¯çº¿æ¦‚å†µ</h4>
                <p><strong>èµ·ç‚¹ï¼š</strong>é•¿å®‰ (ä»Šè¥¿å®‰)</p>
                <p><strong>ç»ˆç‚¹ï¼š</strong>å¤©ç«º (å°åº¦)</p>
                <p><strong>æ—¶é—´ï¼š</strong>629-645å¹´</p>
                <p><strong>å†æ—¶ï¼š</strong>17å¹´</p>
                <p><strong>é‡Œç¨‹ï¼š</strong>çº¦5ä¸‡å…¬é‡Œ</p>
            </div>

            <div class="controls">
                <button class="btn" id="showRouteBtn" onclick="showFullRoute()">æ˜¾ç¤ºå®Œæ•´è·¯çº¿</button>
                <button class="btn" id="resetBtn" onclick="resetView()">é‡ç½®è§†å›¾</button>
                <button class="btn" id="animationBtn" onclick="toggleAnimation()">å¼€å§‹åŠ¨ç”»</button>
            </div>
            <div class="speed-control">
                <label for="speedSlider">åŠ¨ç”»é€Ÿåº¦ï¼š</label>
                <input type="range" id="speedSlider" min="1" max="10" value="3">
                <div class="speed-value" id="speedValue">ä¸­ç­‰</div>
            </div>

            <h3>ä¸»è¦åœ°ç‚¹</h3>
            <div class="location-list" id="locationList">
                <!-- åœ°ç‚¹åˆ—è¡¨å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>

            <div class="legend">
                <h4>å›¾ä¾‹</h4>
                <div class="legend-item">
                    <div class="legend-color route-line"></div>
                    <span>å–ç»è·¯çº¿</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color start-point"></div>
                    <span>èµ·ç‚¹ (é•¿å®‰)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color end-point"></div>
                    <span>ç»ˆç‚¹ (å¤©ç«º)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color way-point"></div>
                    <span>é€”ç»åœ°ç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color animation-marker"></div>
                    <span>åŠ¨ç”»æ ‡è®°</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // åˆå§‹åŒ–åœ°å›¾
        const map = L.map('map').setView([35.0, 80.0], 4);

        // æ·»åŠ åœ°å›¾å›¾å±‚
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // å­˜å‚¨è·¯çº¿å’Œæ ‡è®°çš„å˜é‡
        let routeLayers = []; // å­˜å‚¨å¤šä¸ªè·¯çº¿å›¾å±‚
        let pointLayer = null;
        let markers = [];
        let animationMarker = null;
        let isAnimating = false;
        let routeSegments = []; // å­˜å‚¨å¤šä¸ªè·¯çº¿æ®µçš„åæ ‡æ•°ç»„
        let routeCoordinates = []; // åˆå¹¶åçš„æ‰€æœ‰è·¯çº¿åæ ‡ï¼ˆç”¨äºåŠ¨ç”»ï¼‰
        let keyLocations = [];
        let currentAnimationIndex = 0;
        let animationInterval = null;
        let animationSpeed = 3; // åŠ¨ç”»é€Ÿåº¦ (1-10)
        let autoResetOnComplete = true; // åŠ¨ç”»å®Œæˆåè‡ªåŠ¨é‡ç½®
        let totalRouteDistance = 0; // è·¯çº¿æ€»é•¿åº¦ï¼ˆå…¬é‡Œï¼‰

        // åŠ è½½geojsonæ•°æ®
        async function loadGeoJSONFiles() {
            try {
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                const loadingIndicator = document.createElement('div');
                loadingIndicator.innerHTML = `
                    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                background: rgba(139, 69, 19, 0.9); color: white; padding: 20px;
                                border-radius: 10px; text-align: center; z-index: 1000;">
                        <div style="font-size: 24px; margin-bottom: 10px;">ğŸ“œ</div>
                        <div>æ­£åœ¨åŠ è½½å–ç»è·¯çº¿æ•°æ®...</div>
                        <div style="margin-top: 10px; width: 200px; height: 4px; background: rgba(255,255,255,0.3);
                                    border-radius: 2px; overflow: hidden;">
                            <div style="width: 0%; height: 100%; background: white; transition: width 0.3s;"
                                 id="loadingProgress"></div>
                        </div>
                    </div>
                `;
                document.body.appendChild(loadingIndicator);

                // æ¨¡æ‹ŸåŠ è½½è¿›åº¦
                let progress = 0;
                const progressBar = loadingIndicator.querySelector('#loadingProgress');
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress >= 90) {
                        progress = 90;
                        clearInterval(progressInterval);
                    }
                    progressBar.style.width = progress + '%';
                }, 200);

                // åŠ è½½è·¯çº¿æ•°æ®
                const routeResponse = await fetch('å”ä¸‰è—å–ç»è·¯çº¿.geojson');
                if (!routeResponse.ok) throw new Error('è·¯çº¿æ•°æ®åŠ è½½å¤±è´¥');
                const routeData = await routeResponse.json();

                // åŠ è½½é€”ç»ç‚¹æ•°æ®
                const pointResponse = await fetch('å”ä¸‰è—å–ç»é€”ç»ç‚¹.geojson');
                if (!pointResponse.ok) throw new Error('é€”ç»ç‚¹æ•°æ®åŠ è½½å¤±è´¥');
                const pointData = await pointResponse.json();

                // å®Œæˆè¿›åº¦
                clearInterval(progressInterval);
                progressBar.style.width = '100%';

                // å»¶è¿Ÿç§»é™¤åŠ è½½æŒ‡ç¤ºå™¨
                setTimeout(() => {
                    loadingIndicator.remove();
                    // å¤„ç†è·¯çº¿æ•°æ®
                    processRouteData(routeData);
                    // å¤„ç†é€”ç»ç‚¹æ•°æ®
                    processPointData(pointData);
                    // æ·»åŠ åˆ°åœ°å›¾
                    addDataToMap();

                    // æ˜¾ç¤ºæ€»è·ç¦»
                    if (totalRouteDistance > 0) {
                        document.getElementById('totalDistance').textContent = `${totalRouteDistance.toFixed(1)} å…¬é‡Œ`;
                    }
                }, 500);

            } catch (error) {
                console.error('åŠ è½½GeoJSONæ•°æ®å¤±è´¥:', error);

                // ç§»é™¤åŠ è½½æŒ‡ç¤ºå™¨
                const loadingIndicator = document.querySelector('div[style*="æ­£åœ¨åŠ è½½"]');
                if (loadingIndicator) loadingIndicator.remove();

                // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                const errorMessage = document.createElement('div');
                errorMessage.innerHTML = `
                    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                background: rgba(220, 53, 69, 0.95); color: white; padding: 20px;
                                border-radius: 10px; text-align: center; z-index: 1000;">
                        <div style="font-size: 24px; margin-bottom: 10px;">âŒ</div>
                        <div><strong>æ•°æ®åŠ è½½å¤±è´¥</strong></div>
                        <div style="margin-top: 10px; font-size: 14px;">${error.message}</div>
                        <div style="margin-top: 15px; font-size: 12px; opacity: 0.8;">
                            è¯·ç¡®ä¿ä»¥ä¸‹æ–‡ä»¶å­˜åœ¨ä¸”å¯è®¿é—®ï¼š<br>
                            â€¢ å”ä¸‰è—å–ç»è·¯çº¿.geojson<br>
                            â€¢ å”ä¸‰è—å–ç»é€”ç»ç‚¹.geojson
                        </div>
                        <button onclick="this.parentElement.parentElement.remove();"
                                style="background: white; color: #dc3545; border: none;
                                       padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-top: 15px;">
                            ç¡®å®š
                        </button>
                    </div>
                `;
                document.body.appendChild(errorMessage);
            }
        }

        // å¤„ç†è·¯çº¿æ•°æ®
        function processRouteData(geojson) {
            routeSegments = [];
            routeCoordinates = [];

            if (geojson.features && geojson.features.length > 0) {
                // æŒ‰ç…§featuresæ•°ç»„çš„é¡ºåºå¤„ç†æ¯ä¸ªFeature
                geojson.features.forEach((feature, featureIndex) => {
                    if (feature.geometry && feature.geometry.type === 'LineString') {
                        // æ¯ä¸ªLineStringç‹¬ç«‹å­˜å‚¨ä¸ºä¸€ä¸ªçº¿æ®µ
                        const segmentCoordinates = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                        routeSegments.push({
                            coordinates: segmentCoordinates,
                            featureIndex: featureIndex,
                            properties: feature.properties || {}
                        });

                        // æŒ‰ç…§Featureçš„é¡ºåºæ·»åŠ åæ ‡ï¼Œä¿æŒåŸå§‹é¡ºåº
                        routeCoordinates.push(...segmentCoordinates);

                        console.log(`Feature ${featureIndex}: ${segmentCoordinates.length} ä¸ªåæ ‡ç‚¹`);
                    }
                });

                // è®¡ç®—è·¯çº¿æ€»é•¿åº¦
                totalRouteDistance = calculateRouteDistance(routeCoordinates);
                console.log(`å–ç»è·¯çº¿æ€»é•¿åº¦: ${totalRouteDistance.toFixed(1)} å…¬é‡Œ`);
                console.log(`è·¯çº¿åŒ…å« ${routeSegments.length} ä¸ªç‹¬ç«‹çº¿æ®µ`);
                console.log(`Featuresé¡ºåº: ${geojson.features.map((f, i) => i).join(', ')}`);
            }
        }

        // å¤„ç†é€”ç»ç‚¹æ•°æ®
        function processPointData(geojson) {
            keyLocations = [];

            if (geojson.features && geojson.features.length > 0) {
                geojson.features.forEach((feature, index) => {
                    if (feature.geometry && feature.geometry.type === 'Point') {
                        const coords = feature.geometry.coordinates;
                        const props = feature.properties || {};

                        let type = 'waypoint';
                        if (index === 0) type = 'start';
                        if (index === geojson.features.length - 1) type = 'end';

                        keyLocations.push({
                            name: props.name || `åœ°ç‚¹${index + 1}`,
                            lat: coords[1],
                            lng: coords[0],
                            type: type,
                            description: props.description || '',
                            id: props.id || index
                        });
                    }
                });
            }
        }

        // æ·»åŠ æ•°æ®åˆ°åœ°å›¾
        function addDataToMap() {
            // æ¸…ç©ºä¹‹å‰çš„è·¯çº¿å›¾å±‚
            routeLayers.forEach(layer => map.removeLayer(layer));
            routeLayers = [];

            // æ·»åŠ è·¯çº¿ - æ¯ä¸ªLineStringç‹¬ç«‹ç»˜åˆ¶ï¼ŒæŒ‰ç…§featuresé¡ºåº
            if (routeSegments.length > 0) {
                let allBounds = [];

                // æŒ‰ç…§featureIndexæ’åºï¼Œç¡®ä¿æŒ‰ç…§GeoJSON featuresçš„é¡ºåºæ˜¾ç¤º
                routeSegments.sort((a, b) => a.featureIndex - b.featureIndex);

                routeSegments.forEach((segmentData, index) => {
                    const routeLayer = L.polyline(segmentData.coordinates, {
                        color: '#FF6B6B',
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);

                    // æ·»åŠ popupæ˜¾ç¤ºFeatureä¿¡æ¯
                    routeLayer.bindPopup(`
                        <div style="min-width: 200px;">
                            <h4 style="margin: 0 0 10px 0; color: #8B4513;">è·¯çº¿æ®µ ${segmentData.featureIndex + 1}</h4>
                            <p style="margin: 0 0 10px 0; font-size: 0.9em;">
                                åæ ‡ç‚¹æ•°é‡: ${segmentData.coordinates.length}<br>
                                Featureç´¢å¼•: ${segmentData.featureIndex}
                            </p>
                        </div>
                    `);

                    routeLayers.push(routeLayer);
                    allBounds.push(routeLayer.getBounds());
                });

                // è°ƒæ•´åœ°å›¾è§†å›¾ä»¥é€‚åº”æ‰€æœ‰è·¯çº¿
                if (allBounds.length > 0) {
                    const bounds = L.latLngBounds(allBounds);
                    map.fitBounds(bounds, { padding: [20, 20] });
                }
            }

            // æ·»åŠ é€”ç»ç‚¹æ ‡è®°
            addLocationMarkers();

            // ç”Ÿæˆåœ°ç‚¹åˆ—è¡¨
            generateLocationList();
        }

        // æ·»åŠ åœ°ç‚¹æ ‡è®°
        function addLocationMarkers() {
            keyLocations.forEach((location, index) => {
                let color = '#FF9800'; // é»˜è®¤æ©™è‰²
                if (location.type === 'start') color = '#4CAF50'; // ç»¿è‰²
                if (location.type === 'end') color = '#2196F3'; // è“è‰²

                const icon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background: ${color}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });

                const marker = L.marker([location.lat, location.lng], { icon })
                    .addTo(map)
                    .bindPopup(`
                        <div style="min-width: 250px;">
                            <h4 style="margin: 0 0 10px 0; color: #8B4513;">${location.name}</h4>
                            <p style="margin: 0 0 10px 0; font-size: 0.9em;">${location.description}</p>
                            <p style="margin: 0 0 10px 0; font-size: 0.8em; color: #666;">
                                åæ ‡: ${location.lat.toFixed(4)}, ${location.lng.toFixed(4)}
                            </p>
                            <div style="display: flex; gap: 5px;">
                                <button onclick="map.setView([${location.lat}, ${location.lng}], 10); map.closePopup();"
                                        style="background: #8B4513; color: white; border: none;
                                               padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                                    å®šä½åˆ°æ­¤
                                </button>
                                <button onclick="startAnimationFromIndex(${index})"
                                        style="background: #D2691E; color: white; border: none;
                                               padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em;">
                                    ä»æ­¤å¼€å§‹åŠ¨ç”»
                                </button>
                            </div>
                        </div>
                    `);

                markers.push(marker);
            });
        }

        // ç”Ÿæˆåœ°ç‚¹åˆ—è¡¨
        function generateLocationList() {
            const listContainer = document.getElementById('locationList');
            listContainer.innerHTML = '';

            keyLocations.forEach((location, index) => {
                const item = document.createElement('div');
                item.className = 'location-item';
                item.innerHTML = `
                    <div class="location-name">${location.name}</div>
                    <div class="location-coords">${location.lat.toFixed(4)}, ${location.lng.toFixed(4)}</div>
                `;

                item.addEventListener('click', () => {
                    // ç§»é™¤å…¶ä»–æ´»åŠ¨çŠ¶æ€
                    document.querySelectorAll('.location-item').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');

                    // ç§»åŠ¨åœ°å›¾åˆ°è¯¥åœ°ç‚¹
                    map.setView([location.lat, location.lng], 8);
                    markers[index].openPopup();
                });

                listContainer.appendChild(item);
            });
        }

        // æ˜¾ç¤ºå®Œæ•´è·¯çº¿
        function showFullRoute() {
            if (routeLayers.length > 0) {
                let allBounds = routeLayers.map(layer => layer.getBounds());
                const bounds = L.latLngBounds(allBounds);
                map.fitBounds(bounds, { padding: [20, 20] });
            }
        }

        // é‡ç½®è§†å›¾
        function resetView() {
            if (routeLayers.length > 0) {
                let allBounds = routeLayers.map(layer => layer.getBounds());
                const bounds = L.latLngBounds(allBounds);
                map.fitBounds(bounds, { padding: [20, 20] });
            } else {
                map.setView([35.0, 80.0], 4);
            }
        }

        // åˆ‡æ¢åŠ¨ç”»
        function toggleAnimation() {
            if (isAnimating) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        // å¼€å§‹åŠ¨ç”»
        function startAnimation() {
            if (routeCoordinates.length === 0) {
                alert('è·¯çº¿æ•°æ®å°šæœªåŠ è½½å®Œæˆ');
                return;
            }

            isAnimating = true;
            const button = document.getElementById('animationBtn');
            button.textContent = 'åœæ­¢åŠ¨ç”»';
            button.style.background = '#f44336';

            // æ˜¾ç¤ºè¿›åº¦æ¡
            document.getElementById('animationProgress').style.display = 'block';

            // æ˜¾ç¤ºæµ®åŠ¨è¿›åº¦é¢æ¿
            const floatingPanel = document.getElementById('floatingProgressPanel');
            floatingPanel.style.display = 'block';

            // æ›´æ–°æ€»è·¯ç¨‹æ˜¾ç¤º
            document.getElementById('totalDistanceDisplay').textContent = totalRouteDistance.toFixed(1) + ' km';

            // åˆ›å»ºåŠ¨ç”»æ ‡è®°
            const icon = L.divIcon({
                className: 'animation-marker',
                html: '<div style="background: #E91E63; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4);"></div>',
                iconSize: [22, 22],
                iconAnchor: [11, 11]
            });

            // ç¡®ä¿ä»é€”ç»ç‚¹id=0ï¼ˆé•¿å®‰ï¼‰å¼€å§‹
            let startIndex = 0;
            if (keyLocations.length > 0) {
                // æŸ¥æ‰¾id=0çš„é€”ç»ç‚¹
                const startPoint = keyLocations.find(location => location.id === 0);
                if (startPoint) {
                    // æ‰¾åˆ°è·ç¦»é•¿å®‰æœ€è¿‘çš„è·¯çº¿ç‚¹ä½œä¸ºèµ·å§‹ç‚¹
                    let minDistance = Infinity;
                    for (let i = 0; i < routeCoordinates.length; i++) {
                        const routeCoord = routeCoordinates[i];
                        const distance = calculateDistance(
                            routeCoord[0], routeCoord[1],
                            startPoint.lat, startPoint.lng
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                            startIndex = i;
                        }
                    }
                    console.log(`åŠ¨ç”»å°†ä»é€”ç»ç‚¹id=0ï¼ˆé•¿å®‰ï¼‰å¼€å§‹ï¼Œè·¯çº¿ç´¢å¼•: ${startIndex}`);
                }
            }

            animationMarker = L.marker(routeCoordinates[startIndex], { icon }).addTo(map);
            currentAnimationIndex = startIndex;

            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animateMarker();
        }

        // åŠ¨ç”»å¾ªç¯
        function animateMarker() {
            if (!isAnimating || !animationMarker) return;

            if (currentAnimationIndex >= routeCoordinates.length - 1) {
                // åŠ¨ç”»ç»“æŸ
                stopAnimation();

                // æ˜¾ç¤ºå®Œæˆæ¶ˆæ¯
                const completionMessage = document.createElement('div');
                completionMessage.innerHTML = `
                    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                background: rgba(139, 69, 19, 0.95); color: white; padding: 20px;
                                border-radius: 10px; text-align: center; z-index: 1000;
                                box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                        <h3>ğŸ‰ å–ç»ä¹‹æ—…å®Œæˆï¼</h3>
                        <p>ç„å¥˜æ³•å¸ˆå†ç»17å¹´ï¼Œç»ˆäºæŠµè¾¾å¤©ç«ºå–å¾—çœŸç»</p>
                        <p style="font-size: 0.9em; opacity: 0.8;">å·²æŒ‰ç…§GeoJSON featuresé¡ºåºå®Œæˆæ‰€æœ‰è·¯çº¿æ®µ</p>
                        <button onclick="this.parentElement.parentElement.remove();"
                                style="background: white; color: #8B4513; border: none;
                                       padding: 8px 16px; border-radius: 5px; cursor: pointer;">å…³é—­</button>
                    </div>
                `;
                document.body.appendChild(completionMessage);

                // 3ç§’åè‡ªåŠ¨ç§»é™¤æ¶ˆæ¯
                setTimeout(() => {
                    if (completionMessage.parentElement) {
                        completionMessage.remove();
                    }
                }, 3000);

                // å¦‚æœå¯ç”¨äº†è‡ªåŠ¨é‡ç½®ï¼Œå»¶è¿Ÿåé‡ç½®è§†å›¾
                if (autoResetOnComplete) {
                    setTimeout(() => {
                        resetView();
                    }, 2000);
                }
                return;
            }

            // ç§»åŠ¨æ ‡è®°
            animationMarker.setLatLng(routeCoordinates[currentAnimationIndex]);

            // æ›´æ–°è¿›åº¦å’Œè¯¦ç»†ä¿¡æ¯
            const progress = getAnimationProgress();
            const completedDistance = getCompletedDistance();
            const remainingDistance = totalRouteDistance - completedDistance;

            document.getElementById('progressFill').style.width = progress + '%';

            // æ›´æ–°æµ®åŠ¨è¿›åº¦é¢æ¿
            document.getElementById('progressFillLarge').style.width = progress + '%';
            document.getElementById('progressTextLarge').textContent = progress.toFixed(1) + '%';
            document.getElementById('completedDistance').textContent = completedDistance.toFixed(1) + ' km';
            document.getElementById('remainingDistance').textContent = remainingDistance.toFixed(1) + ' km';

            // æ›´æ–°å½“å‰ä½ç½®ä¿¡æ¯
            updateCurrentLocation();

            // è·å–å½“å‰æ‰€åœ¨çš„Featureæ®µä¿¡æ¯
            let currentFeatureIndex = 0;
            let currentFeatureProgress = 0;
            let accumulatedPoints = 0;

            for (let i = 0; i < routeSegments.length; i++) {
                if (currentAnimationIndex < accumulatedPoints + routeSegments[i].coordinates.length) {
                    currentFeatureIndex = i;
                    currentFeatureProgress = ((currentAnimationIndex - accumulatedPoints) / routeSegments[i].coordinates.length) * 100;
                    break;
                }
                accumulatedPoints += routeSegments[i].coordinates.length;
            }

            // åœ¨è¿›åº¦æ¡åŒºåŸŸæ˜¾ç¤ºæ›´è¯¦ç»†çš„ä¿¡æ¯
            const currentCoord = routeCoordinates[currentAnimationIndex];
            document.getElementById('currentLocation').innerHTML = `
                <div style="font-size: 12px;">
                    <div><strong>å½“å‰ä½ç½®:</strong> ${currentCoord[1].toFixed(4)}, ${currentCoord[0].toFixed(4)}</div>
                    <div style="margin-top: 3px;">
                        <strong>è¿›åº¦:</strong> ${completedDistance.toFixed(1)}km / ${totalRouteDistance.toFixed(1)}km
                        <span style="color: #666;">(å‰©ä½™ ${remainingDistance.toFixed(1)}km)</span>
                    </div>
                    <div style="margin-top: 3px; color: #666; font-size: 0.9em;">
                        <strong>å½“å‰è·¯çº¿æ®µ:</strong> Feature ${currentFeatureIndex + 1} (${currentFeatureProgress.toFixed(1)}%)
                    </div>
                </div>
            `;

            // ç§»åŠ¨åœ°å›¾è§†è§’
            if (currentAnimationIndex % 50 === 0) { // æ¯50ä¸ªç‚¹è°ƒæ•´ä¸€æ¬¡è§†è§’
                map.setView(routeCoordinates[currentAnimationIndex], map.getZoom());
            }

            currentAnimationIndex += animationSpeed; // æ ¹æ®é€Ÿåº¦è°ƒæ•´æ­¥é•¿

            // ç»§ç»­åŠ¨ç”»
            if (isAnimating) {
                const delay = Math.max(50, 200 - (animationSpeed * 20)); // é€Ÿåº¦è¶Šå¿«ï¼Œå»¶è¿Ÿè¶ŠçŸ­
                setTimeout(animateMarker, delay);
            }
        }

        // æ›´æ–°å½“å‰ä½ç½®ä¿¡æ¯
        function updateCurrentLocation() {
            if (currentAnimationIndex >= routeCoordinates.length || keyLocations.length === 0) return;

            const currentCoord = routeCoordinates[currentAnimationIndex];
            let nearestLocation = keyLocations[0];
            let minDistance = calculateDistance(currentCoord[0], currentCoord[1], keyLocations[0].lat, keyLocations[0].lng);

            // æ‰¾åˆ°æœ€è¿‘çš„å·²çŸ¥åœ°ç‚¹
            for (let i = 1; i < keyLocations.length; i++) {
                const distance = calculateDistance(currentCoord[0], currentCoord[1], keyLocations[i].lat, keyLocations[i].lng);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestLocation = keyLocations[i];
                }
            }

            const locationText = minDistance < 1 ? `å½“å‰ï¼š${nearestLocation.name}` : `é™„è¿‘ï¼š${nearestLocation.name}`;
            document.getElementById('currentLocation').textContent = locationText;

            // æ›´æ–°æµ®åŠ¨é¢æ¿ä¸­çš„å½“å‰ä½ç½®
            document.getElementById('currentLocationText').textContent = locationText;
        }

        // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // åœ°çƒåŠå¾„ï¼ˆå…¬é‡Œï¼‰
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // åœæ­¢åŠ¨ç”»
        function stopAnimation() {
            isAnimating = false;
            const button = document.getElementById('animationBtn');
            button.textContent = 'å¼€å§‹åŠ¨ç”»';
            button.style.background = '#8B4513';

            // éšè—è¿›åº¦æ¡
            document.getElementById('animationProgress').style.display = 'none';

            // éšè—æµ®åŠ¨è¿›åº¦é¢æ¿
            document.getElementById('floatingProgressPanel').style.display = 'none';

            if (animationMarker) {
                map.removeLayer(animationMarker);
                animationMarker = null;
            }

            currentAnimationIndex = 0;
        }

        // è¾…åŠ©å‡½æ•°ï¼šé£åˆ°æŒ‡å®šä½ç½®
        function flyToLocation(lat, lng) {
            map.flyTo([lat, lng], 10, {
                animate: true,
                duration: 1.5
            });
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—è·¯çº¿è·ç¦»ï¼ˆä½¿ç”¨Haversineå…¬å¼ï¼‰
        function calculateRouteDistance(coordinates) {
            let totalDistance = 0;

            for (let i = 0; i < coordinates.length - 1; i++) {
                const [lng1, lat1] = coordinates[i];
                const [lng2, lat2] = coordinates[i + 1];

                // Haversineå…¬å¼è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
                const R = 6371; // åœ°çƒåŠå¾„ï¼ˆå…¬é‡Œï¼‰
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;

                totalDistance += distance;
            }

            return totalDistance;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè·å–å½“å‰åŠ¨ç”»è¿›åº¦
        function getAnimationProgress() {
            if (!routeCoordinates || routeCoordinates.length === 0) return 0;
            return (currentAnimationIndex / (routeCoordinates.length - 1)) * 100;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè·å–å·²å®Œæˆçš„è·ç¦»
        function getCompletedDistance() {
            if (!routeCoordinates || routeCoordinates.length === 0 || currentAnimationIndex === 0) return 0;

            let completedDistance = 0;
            for (let i = 0; i < Math.min(currentAnimationIndex, routeCoordinates.length - 1); i++) {
                const [lng1, lat1] = routeCoordinates[i];
                const [lng2, lat2] = routeCoordinates[i + 1];

                // Haversineå…¬å¼
                const R = 6371;
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLng = (lng2 - lng1) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLng/2) * Math.sin(dLng/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;

                completedDistance += distance;
            }

            return completedDistance;
        }

        // è¾…åŠ©å‡½æ•°ï¼šä»æŒ‡å®šç´¢å¼•å¼€å§‹åŠ¨ç”»
        function startAnimationFromIndex(index) {
            if (!routeCoordinates || routeCoordinates.length === 0) {
                alert('è·¯çº¿æ•°æ®å°šæœªåŠ è½½å®Œæˆ');
                return;
            }

            if (index < 0 || index >= waypointsData.features.length) {
                alert('æ— æ•ˆçš„åœ°ç‚¹ç´¢å¼•');
                return;
            }

            const feature = waypointsData.features[index];
            const coords = feature.geometry.coordinates;

            // æ‰¾åˆ°æœ€è¿‘çš„è·¯çº¿ç‚¹
            let nearestIndex = 0;
            let minDistance = Infinity;

            for (let i = 0; i < routeCoordinates.length; i++) {
                const routeCoord = routeCoordinates[i];
                const distance = Math.sqrt(
                    Math.pow(routeCoord[0] - coords[0], 2) +
                    Math.pow(routeCoord[1] - coords[1], 2)
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = i;
                }
            }

            // åœæ­¢å½“å‰åŠ¨ç”»
            stopAnimation();

            // è®¾ç½®åŠ¨ç”»èµ·å§‹ç‚¹
            currentAnimationIndex = nearestIndex;

            // ç§»åŠ¨åˆ°è¯¥ä½ç½®
            flyToLocation(coords[1], coords[0]);

            // å¼€å§‹åŠ¨ç”»
            setTimeout(() => {
                startAnimation();
            }, 1500);
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            loadGeoJSONFiles();

            // è®¾ç½®é€Ÿåº¦æ»‘å—äº‹ä»¶ç›‘å¬
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');

            speedSlider.addEventListener('input', (e) => {
                animationSpeed = parseInt(e.target.value);
                const speedTexts = ['å¾ˆæ…¢', 'æ…¢', 'è¾ƒæ…¢', 'ä¸­ç­‰', 'è¾ƒå¿«', 'å¿«', 'å¾ˆå¿«', 'éå¸¸å¿«', 'æå¿«', 'æœ€å¿«'];
                speedValue.textContent = speedTexts[animationSpeed - 1] || 'ä¸­ç­‰';
            });

            // åˆå§‹åŒ–é€Ÿåº¦æ˜¾ç¤º
            speedSlider.dispatchEvent(new Event('input'));
        });

        // æ·»åŠ è‡ªå®šä¹‰æ ·å¼
        const style = document.createElement('style');
        style.textContent = `
            .custom-marker {
                background: transparent !important;
                border: none !important;
            }
            .leaflet-popup-content-wrapper {
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            }
            .leaflet-popup-tip {
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
